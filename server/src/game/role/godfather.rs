use serde::Serialize;

use crate::game::attack_power::{AttackPower, DefensePower};
use crate::game::chat::{ChatGroup, ChatMessageVariant};
use crate::game::components::insider_group::InsiderGroupID;
use crate::game::grave::GraveKiller;
use crate::game::player::PlayerReference;

use crate::game::role_list::RoleSet;
use crate::game::tag::Tag;
use crate::game::visit::Visit;

use crate::game::Game;
use super::{Priority, RoleStateImpl, RoleState};


#[derive(Debug, Clone, Serialize, Default)]
pub struct Godfather{
    backup: Option<PlayerReference>
}


pub(super) const MAXIMUM_COUNT: Option<u8> = Some(1);
pub(super) const DEFENSE: DefensePower = DefensePower::Armor;

impl RoleStateImpl for Godfather {
    type ClientRoleState = Godfather;
    fn do_night_action(self, game: &mut Game, actor_ref: PlayerReference, priority: Priority) {
        Self::night_ability(self.backup, game, actor_ref, priority);
    }
    fn can_select(self, game: &Game, actor_ref: PlayerReference, target_ref: PlayerReference) -> bool {
        crate::game::role::common_role::can_night_select(game, actor_ref, target_ref) &&
        game.day_number() > 1
    }
    fn do_day_action(self, game: &mut Game, actor_ref: PlayerReference, target_ref: PlayerReference) {
        if let Some(old_target_ref) = self.backup {
            if old_target_ref == target_ref {
                actor_ref.set_role_state(game, RoleState::Godfather(Godfather{backup: None}));
            } else {
                actor_ref.set_role_state(game, RoleState::Godfather(Godfather{backup: Some(target_ref)}));
            }
        } else {
            actor_ref.set_role_state(game, RoleState::Godfather(Godfather{backup: Some(target_ref)}));
        }

        let RoleState::Godfather(Godfather { backup }) = *actor_ref.role_state(game) else {
            unreachable!("Role was just set to Godfather");
        };

        game.add_message_to_chat_group(ChatGroup::Mafia, ChatMessageVariant::GodfatherBackup { backup: backup.map(|p|p.index()) });

        for player_ref in PlayerReference::all_players(game){
            if !InsiderGroupID::Mafia.is_player_in_revealed_group(game, player_ref) {
                continue;
            }
            player_ref.remove_player_tag_on_all(game, Tag::GodfatherBackup);
        }

        if let Some(backup) = backup {
            for player_ref in PlayerReference::all_players(game){
                if !InsiderGroupID::Mafia.is_player_in_revealed_group(game, player_ref) {
                    continue;
                }
                player_ref.push_player_tag(game, backup, Tag::GodfatherBackup);
            }
        }
        
    }
    fn can_day_target(self, game: &Game, actor_ref: PlayerReference, target_ref: PlayerReference) -> bool {
        actor_ref != target_ref &&
        actor_ref.alive(game) && target_ref.alive(game) &&
        RoleSet::Mafia.get_roles().contains(&target_ref.role(game)) &&
        InsiderGroupID::Mafia.is_player_in_revealed_group(game, target_ref)
    }
    fn convert_selection_to_visits(self, game: &Game, actor_ref: PlayerReference, target_refs: Vec<PlayerReference>) -> Vec<Visit> {
        crate::game::role::common_role::convert_selection_to_visits(game, actor_ref, target_refs, true)
    }
    fn on_any_death(self, game: &mut Game, actor_ref: PlayerReference, dead_player_ref: PlayerReference){

        if actor_ref == dead_player_ref {
            let Some(backup) = self.backup else {return};

            actor_ref.set_role_state(game, RoleState::Godfather(Godfather{backup: None}));
            for player_ref in PlayerReference::all_players(game){
                if !InsiderGroupID::Mafia.is_player_in_revealed_group(game, player_ref) {
                    continue;
                }
                player_ref.remove_player_tag_on_all(game, Tag::GodfatherBackup);
            }
            
            if !backup.alive(game){return}

            //convert backup to godfather
            backup.set_role_and_win_condition_and_revealed_group(game, RoleState::Godfather(Godfather{backup: None}));
        }
        else if self.backup.is_some_and(|p|p == dead_player_ref) {
            actor_ref.set_role_state(game, RoleState::Godfather(Godfather{backup: None}));
        }
    }
     fn default_revealed_groups(self) -> crate::vec_set::VecSet<crate::game::components::insider_group::InsiderGroupID> {
        vec![
            crate::game::components::insider_group::InsiderGroupID::Mafia
        ].into_iter().collect()
    }
}

impl Godfather{
    pub(super) fn night_ability(backup: Option<PlayerReference>, game: &mut Game, actor_ref: PlayerReference, priority: Priority) {
        if game.day_number() == 1 {return}

        match priority {
            //set backup to be attacking
            Priority::Deception => {
                if !actor_ref.night_blocked(game) {return}

                let Some(backup) = backup else {return};
                let mut visits = backup.night_visits(game).clone();

                let Some(visit) = visits.first_mut() else {return};

                visit.attack = true;
        
                game.add_message_to_chat_group(ChatGroup::Mafia, 
                    ChatMessageVariant::GodfatherBackupKilled { backup: backup.index() }
                );
                
                backup.set_night_visits(game, visits);
            },
            //kill the target
            Priority::Kill => {
                if actor_ref.night_blocked(game) {
                    let Some(backup) = backup else {return};
                    let Some(visit) = backup.night_visits(game).first() else {return};
                    visit.target.clone().try_night_kill_single_attacker(
                        backup, game, GraveKiller::RoleSet(RoleSet::Mafia), 
                        AttackPower::Basic, false
                    );
                }else{
                    let Some(visit) = actor_ref.night_visits(game).first() else {return};
                    visit.target.clone().try_night_kill_single_attacker(
                        actor_ref, game, GraveKiller::RoleSet(RoleSet::Mafia),
                        AttackPower::Basic, false
                    );
                }
            },
            _ => return
        }
    }
}